#+Title Just another Love Song: Common Lisp in 2017
#+OPTIONS: num:nil ^:{}
* An RTFM Language
There's good news and bad news.

Googling up blogs and tutorials and questions on StackOverflow works pretty well for some languages like Python and Javascript. Common Lisp is probably not one of them (though I recognize the irony that this text might suggest). In part by the historical necessities of the pre-internet age and in part by historical accident that Common Lisp was primarily designed for professional programmers and not students (Scheme wound up filling part of that role), learning Common Lisp involves reading material that is designed for professional programmers. There are introductory resources like /Land of Lisp/, but most material is at the "here are some compiler directives" level of engagement.

Fortunately, Common Lisp is a standard and a description of the language is available online: [[https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html][Common Lisp: The Language (2nd Edition)]]
* Symbols, Packages, 'Packages', and Systems
This section will go into terminology regarding multiple file organization in Common Lisp because it is a bit disorienting.
** Symbols and Packages
*** Symbols
In Common Lisp a symbol is not just a name. A symbol is a [[http://www.lispworks.com/documentation/lw70/CLHS/Body/t_symbol.htm][compound data structure]]. It might be useful to think about a symbol as the name of a pointer to a data structure...sometimes I think it is useful to think about everything in Common Lisp as a pointer.

A symbol may be interned or uninterned. An interned symbol is interned because it is interned in a package.
*** Packages
A package is a compound data structure that contains symbols.
#+BEGIN_QUOTE
Packages are collections of symbols that serve as namespaces. The parser recognizes symbols by looking up character sequences in the current package.
#+END_QUOTE
** 'Packages' and Systems
* The Lisp Machine
This section will go into the idea of Common Lisp as a way of /using/ a computer rather than a way of /programming/ a computer.
** An abstraction over Von Neumann Architecture
* Opinions
There are many possible permutations of Common Lisp environments [something like =O(n!)= I think]. This is my snowflake opinion, not for the sake of argument, but for the sake of swimming downstream in the middle of the channel. It is premised on using open source tooling (i.e. not spending any money). 

There are legitimate reasons to use commercial implementations. There might be legitemate reasons to make choices other than those I describe, but they will tend to increase the probability of swimming against the current.

The /tl;dr/ is choosing projects that are mature, robust, well maintained, and in widespread use by *experienced* Common Lisp users because such project help promote a common vocabulary and common frame of reference.
** SBCL
 There are two good reasons for using SBCL [Steel Bank Common Lisp]. t is the most straight forward from an open source perspective.
** ~/common-lisp
 Just put your files there like an *nix'er.
** ASDF
 ASDF does one thing.
 #+NAME: kludgecode-use-system
 #+BEGIN_SRC lisp :tangle kludge-use-system.lisp
   (in-package :kludgecode)
   (def use-system (system-keyword)
     "Loads a system if locally available, otherwise trys to fetch it via quicklisp"
     (if (asdf:system-registered-p system-keyword)
         (progn
           (asdf:load-system system-keyword)
           'asdf-loaded)
         (progn 
           (ql:quickload system-keyword)
           'quickloaded)))
 #+END_SRC
** Quicklisp
*** Installation 
 Quicklisp is a package manager for common Lisp available at [[https://www.quicklisp.org/beta/][https://www.quicklisp.org/beta/]].
 #+BEGIN_SRC shell :results none
   mkdir ~/common-lisp/quicklisp-install
   cd ~/common-lisp/quicklisp-install
   curl -O https://beta.quicklisp.org/quicklisp.lisp
   curl -O https://beta.quicklisp.org/quicklisp.lisp.asc
   gpg --verify quicklisp.lisp.asc quicklisp.lisp
 #+END_SRC

 #+BEGIN_SRC shell :results none
 sbcl --load quicklisp.lisp
 #+END_SRC
*** System Repository
 https://www.quicklisp.org/beta/releases.html
** Emacs
 There are two good reasons for using Emacs as the environment for developing Common Lisp:

 1. It is pretty much the standard alternative to commerical tools.
 2. Emacs Lisp allows building tools to make your life easier, and while Emacs Lisp is not Common Lisp, it's still loveable (as are all lisps).
* Testing
** lisp-unit
As the name implies, =lisp-uint= is an Xunit inspired unit testing framework.
It should be installed using =quicklisp=:
#+BEGIN_EXAMPLE
  (ql:quickload :lisp-unit)
#+END_EXAMPLE
Basic documentation is on github: https://github.com/OdonataResearchLLC/lisp-unit/wiki
* Other Lisps
* Signposts - Finding the Right Lisp
Finding the right Lisp because Common Lisp is not necessarily the right lisp for you.

+ Racket for newbies and students and SICP.
+ Emacs Lisp for a practical reason to learn lisp
+ Clojure -> Clojure from the ground up
+ SBCL in Bash
